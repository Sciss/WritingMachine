package de.sciss.grapheme

import de.sciss.lucre.stm.{NoSys, Sys}
import de.sciss.synth.proc.Implicits._
import de.sciss.synth.proc.{Folder, Proc}
import de.sciss.synth.proc.graph.{ScanIn, ScanInFix, ScanOut}
import de.sciss.synth.{GE, SynthGraph}

import scala.concurrent.stm.TxnLocal
import scala.language.implicitConversions

object DSL {
  def apply[S <: Sys[S]]: DSL[S] = anyDSL.asInstanceOf[DSL[S]]

  private[this] val anyDSL = new DSL[NoSys]

  final class ProcOps[S <: Sys[S]](private val p: Proc[S]) extends AnyVal {
    def ~> (that: Proc[S])(implicit tx: S#Tx): Unit = {
      /* val out = */ p.outputs.add(Proc.mainOut)
      val attr = that.attr
      attr.get(Proc.mainIn) match {
        case Some(f: Folder[S]) =>
          f.addLast(p)
        case Some(other : Proc[S]) =>
          val f = Folder[S]
          f.addLast(other)
          f.addLast(p)
          attr.put(Proc.mainIn, f)
        case _ =>
          attr.put(Proc.mainIn, p)
      }
    }
  }
}
final class DSL[S <: Sys[S]] {
  private[this] val current = TxnLocal[Proc[S]]()

  def filter(name: String, numChannels: Int = -1)(fun: GE => GE)(implicit tx: S#Tx): Proc[S] = {
    val obj = mkProcObj(name) {
      val in  = if (numChannels == -1) ScanIn() else ScanInFix(numChannels)
      val out = fun(in)
      ScanOut(Proc.mainOut, out)
    }
    val proc  = obj
    proc.outputs.add(Proc.mainOut)
//    insertByName(n.filters.get, obj)
    obj
  }

  /** Creates a `Proc.Obj` with a synth-graph whose function
    * is determined by the `fun` argument.
    *
    * @param name name to assign to the resulting object
    * @param fun  the function that creates the synth-graph
    * @return     an object whose `Proc` has a synth-graph with the
    *             content generated by `fun` and the supplied `name`
    */
  def mkProcObj(name: String)(fun: => Unit)(implicit tx: S#Tx /* , n: Nuages[S] */): Proc[S] = {
    val p   = Proc[S]
    p.name  = name
    current.set(p)(tx.peer)
    p.graph() = SynthGraph { fun }
    current.set(null)(tx.peer)
    p
  }

  implicit def ProcOps(p: Proc[S]): DSL.ProcOps[S] = new DSL.ProcOps(p)
}